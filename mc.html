<!DOCTYPE html>
<html>
<head>
    <title>MineClone Single File</title>
    <meta charset="UTF-8">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: monospace;
             user-select: none;
            -webkit-user-select: none; /* Safari */
        }
        canvas {
            display: block;
        }
         #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 10px;
            background: rgba(255, 255, 255, 0.6);
             transform: translate(-50%, -50%);
             pointer-events: none;
             z-index: 10;
              display: none; /* hidden until lock */
        }
         #crosshair::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 2px;
             background: rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%);
         }
          #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px;
            border-radius: 5px;
             pointer-events: none;
              z-index: 11;
              font-size: 12px;
              text-shadow: 1px 1px 1px black;
        }
        #hotbar {
             position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.5);
             padding: 2px;
             z-index: 12;
              pointer-events: none;
        }
         .slot {
           width: 40px;
           height: 40px;
           border: 2px solid rgba(100,100,100,0.8);
            margin: 2px;
            box-sizing: border-box;
             display: flex;
             align-items: center;
             justify-content: center;
             font-size: 24px;
              text-shadow: 2px 2px 2px black;
              color: white;
              image-rendering: pixelated; /* help canvas scale */
             image-rendering: crisp-edges;
         }
          .slot.selected {
             border-color: white;
              transform: scale(1.1);
               background: rgba(255,255,255, 0.2);
          }
           .slot canvas {
             width: 100%;
             height: 100%;
           }

           #blocker {
              position: absolute;
              width: 100%;
              height: 100%;
              background-color: rgba(0,0,0,0.7);
               display: flex;
               align-items: center;
               justify-content: center;
               color: white;
                font-size: 24px;
                 cursor: pointer;
                  z-index: 100;
                   flex-direction: column;
            }
            #status { color: yellow; font-size: 16px; margin-top: 10px;}

    </style>
</head>

<body>
    <div id="blocker">
       <div>Click to Play / Lock Pointer</div>
       <div id="status">(Loading...)</div>
       <div>(ESC to unlock)</div>
     </div>
     <div id="crosshair"></div>
     <div id="hotbar"></div>
      <div id="instructions">
        WASD: Move<br>
        SPACE: Jump<br>
        MOUSE: Look<br>
        L-CLICK: Break<br>
        R-CLICK: Place<br>
        1-7 / SCROLL: Select Block<br>
         ESC: Release Cursor<br>
         <span id="posDebug">Pos: 0,0,0</span>
      </div>

    <!-- Dependencies via CDN -->
      <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
      <script type="importmap">
       {
         "imports": {
           "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
            "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
         }
       }
      </script>

    <!-- MAIN GAME SCRIPT -->
    <script type="module">
       // Using Module type to allow imports
      import * as THREE from 'three';
       // Make sure correct import style is used
      import { createNoise2D } from 'simplex-noise';
     
     const statusDiv = document.getElementById('status');
     const posDebug = document.getElementById('posDebug');
     statusDiv.textContent = 'Imports loaded...';
     console.log("MineClone Init...");

      // --- CONSTANTS ---
      const CHUNK_SIZE = 16;
      const WORLD_HEIGHT = 64; // Keep low for performance
      const RENDER_DISTANCE_CHUNKS = 3; // !! Keep low! 3 means 7x7 chunk area
      const WATER_LEVEL = 28;
      const MAX_RAYCAST_DIST = 6;
      const PLAYER_HEIGHT = 1.7; // Eye level
      const PLAYER_RADIUS = 0.3;
      const GRAVITY = -20;
      const JUMP_VELOCITY = 8;
      const MOVE_SPEED = 5;
       const MOUSE_SENSITIVITY = 0.002;
       const TEXTURE_SIZE = 16; // Pixels for generated textures

       const BLOCK_TYPE = {
           AIR: 0,
           GRASS: 1,
           DIRT: 2,
           STONE: 3,
           WOOD: 4,
           LEAVES: 5,
           SAND: 6,
           WATER: 7,
           COBBLE: 8, // Placeable stone
       };
       // Blocks the player can select & place
       const PLACEABLE_BLOCKS = [
            BLOCK_TYPE.GRASS, BLOCK_TYPE.DIRT, BLOCK_TYPE.COBBLE,
            BLOCK_TYPE.WOOD, BLOCK_TYPE.LEAVES, BLOCK_TYPE.SAND, BLOCK_TYPE.WATER
       ];
        // IMPORTANT FIX: Define OPAQUE blocks for visibility checks. If neighbour is not opaque, face is drawn.
        const OPAQUE_BLOCKS = new Set(Object.values(BLOCK_TYPE));
        OPAQUE_BLOCKS.delete(BLOCK_TYPE.AIR);
        OPAQUE_BLOCKS.delete(BLOCK_TYPE.LEAVES); // Treat leaves as non-opaque for culling neighbour blocks
        OPAQUE_BLOCKS.delete(BLOCK_TYPE.WATER);

         // Blocks that stop the player
         const SOLID_BLOCKS_COLLISION = new Set(Object.values(BLOCK_TYPE));
         SOLID_BLOCKS_COLLISION.delete(BLOCK_TYPE.AIR);
          SOLID_BLOCKS_COLLISION.delete(BLOCK_TYPE.WATER); // Can walk through water
           SOLID_BLOCKS_COLLISION.delete(BLOCK_TYPE.LEAVES); // Can walk through leaves


      // --- GLOBALS ---
      let scene, camera, renderer, raycaster, pointerLockElement;
      let world;
      let noise2D;
      const materials = {};
      const instancedMeshes = {}; // Map<blockType, THREE.InstancedMesh>
       const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        // Center player in the generated world
       const startX = CHUNK_SIZE * RENDER_DISTANCE_CHUNKS + CHUNK_SIZE/2;
       const startZ = CHUNK_SIZE * RENDER_DISTANCE_CHUNKS + CHUNK_SIZE/2;
       const player = {
            position: new THREE.Vector3(startX, WORLD_HEIGHT + 5, startZ),
            velocity: new THREE.Vector3(),
            onGround: false,
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
             isLocked : false,
        };
       const cameraPitch = new THREE.Object3D();
       const cameraYaw = new THREE.Object3D();
       let selectionHighlightMesh;
       let lastTime = performance.now();
        let debugTime = performance.now();
       let selectedBlockTypeIndex = 0;
       const hotbarSlots = [];
       let simpleMob;
       let isReady = false;

       // Max instances per mesh (pre-allocate) - calculated for the render area size
       const WORLD_DIAMETER_CHUNKS = RENDER_DISTANCE_CHUNKS * 2 + 1;
       const MAX_POSSIBLE_BLOCKS = WORLD_DIAMETER_CHUNKS * WORLD_DIAMETER_CHUNKS * CHUNK_SIZE * CHUNK_SIZE * WORLD_HEIGHT;
       const MAX_BLOCKS_PER_TYPE =  Math.ceil(MAX_POSSIBLE_BLOCKS / 6) ; // generous estimate


      // --- TEXTURE GENERATION (Canvas 2D) ---
       function createPixelTexture(colors, patternFn) {
           const canvas = document.createElement('canvas');
           canvas.width = TEXTURE_SIZE;
           canvas.height = TEXTURE_SIZE;
           const ctx = canvas.getContext('2d');
            // ctx.imageSmoothingEnabled = false; // Should be default, but explicit

           for (let y = 0; y < TEXTURE_SIZE; y++) {
               for (let x = 0; x < TEXTURE_SIZE; x++) {
                    ctx.fillStyle = patternFn(x, y, colors);
                     ctx.fillRect(x, y, 1, 1);
               }
           }
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter; // CRUCIAL FOR PIXEL LOOK
            texture.minFilter = THREE.NearestFilter; //THREE.LinearMipmapLinearFilter; // Linear helps with distance shimmer
             texture.generateMipmaps = false; // Avoid mipmaps for nearest filter
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
       }

       function noisyPattern(x,y, colors) {
           return colors[Math.floor(Math.random() * colors.length)];
       }
        function noisyAlphaPattern(x,y, colors) {
           // Ensure some full transparency for leaves
            if (Math.random() < 0.15) return 'rgba(0,0,0,0)';
           return colors[Math.floor(Math.random() * colors.length)];
       }
       function grassTopPattern(x,y, colors) {
           const base = colors.dirt[Math.floor(Math.random() * colors.dirt.length)];
           const overlay = colors.grass[Math.floor(Math.random() * colors.grass.length)];
            if(Math.random() > 0.45) return overlay;
            return base;
       }
        function woodPattern(x,y, colors) {
            const base = colors[Math.floor(Math.random() * colors.length)];
             if ((x + y * 0.5) % 4 < 0.8 && Math.random() > 0.3 ) return "#402810"; //dark lines
             return base;
        }
         function woodTopPattern(x,y, colors) {
            const base = colors[Math.floor(Math.random() * colors.length)];
             const dx = x - TEXTURE_SIZE/2 + 0.5;
             const dy = y - TEXTURE_SIZE/2 + 0.5;
             const dist = Math.sqrt(dx*dx + dy*dy);
             if (dist > 0.5 && dist % 2.5 < 0.7 && Math.random() > 0.3 ) return "#402810"; //rings
             return base;
        }


      function createMaterials() {
         statusDiv.textContent = 'Generating Textures...';
         const dirtColors = ["#614226", "#593e23", "#69492a"];
         const stoneColors = ["#777777", "#888888", "#808080", "#707070"];
          const grassColors = ["#487134", "#3e612d", "#507d3a", "#5a8a42"];
           const woodColors = ["#6d4c2b", "#7a5632", "#875f35"];
           const leaveColors = ["#228B22aa", "#2e8b2eaa", "#387038aa"]; // add some alpha
           const sandColors = ["#dbca96", "#e3d3a1", "#c9b988"];
            const waterColors = ["rgba(30, 100, 220, 0.6)", "rgba(40, 110, 230, 0.6)","rgba(20, 90, 200, 0.6)"];

         const dirtTex = createPixelTexture(dirtColors, noisyPattern);
         const stoneTex = createPixelTexture(stoneColors, noisyPattern);
         const cobbleTex = createPixelTexture(["#666", "#777", "#6a6a6a", "#5c5c5c"], noisyPattern);
          const grassSideTex = createPixelTexture({dirt: dirtColors, grass: grassColors}, (x,y,c) => y < TEXTURE_SIZE / 3.5 ? grassTopPattern(x,y,c) : noisyPattern(x,y,c.dirt) );
          const grassTopTex = createPixelTexture({dirt: dirtColors, grass: grassColors}, grassTopPattern);
           const woodSideTex = createPixelTexture(woodColors, woodPattern);
            const woodTopTex = createPixelTexture(woodColors, woodTopPattern);
             const leaveTex = createPixelTexture(leaveColors, noisyAlphaPattern);
              const sandTex = createPixelTexture(sandColors, noisyPattern);
               const waterTex = createPixelTexture(waterColors, noisyPattern);

          const basicMat = (tex, transparent = false, opacity=1.0) => new THREE.MeshLambertMaterial({
                map: tex,
                transparent: transparent,
                opacity: opacity,
                alphaTest: transparent ? 0.2 : 0 // FIX: helps with leaf transparency borders
           });

           materials[BLOCK_TYPE.DIRT] = basicMat(dirtTex);
           materials[BLOCK_TYPE.STONE] = basicMat(stoneTex);
            materials[BLOCK_TYPE.COBBLE] = basicMat(cobbleTex);
           materials[BLOCK_TYPE.SAND] = basicMat(sandTex);
           materials[BLOCK_TYPE.LEAVES] = basicMat(leaveTex, true);
            materials[BLOCK_TYPE.WATER] = basicMat(waterTex, true, 0.7);

           materials[BLOCK_TYPE.GRASS] = [ // side, side, top, bottom, side, side
                basicMat(grassSideTex), basicMat(grassSideTex),
                basicMat(grassTopTex), basicMat(dirtTex),
                basicMat(grassSideTex), basicMat(grassSideTex),
           ];
            materials[BLOCK_TYPE.WOOD] = [
                basicMat(woodSideTex), basicMat(woodSideTex),
                basicMat(woodTopTex), basicMat(woodTopTex), // top, bottom
                basicMat(woodSideTex), basicMat(woodSideTex),
           ];
            console.log("Materials created");
      }

       // --- WORLD MANAGEMENT ---
        class World {
            constructor() {
                 this.chunks = new Map(); // Store block data: 'x,z' => Uint8Array
                  this.meshQueue = new Set(); // Chunks needing mesh update
                  // Store pre-calculated matrices per chunk AND type: 'cx,cz,type' => [matrix, matrix...]
                  this.chunkMatrices = new Map();
            }

            _chunkKey(cx, cz) { return `${cx},${cz}`; }
             _matrixKey(cx, cz, type) { return `${cx},${cz},${type}`; }
            _blockIndex(x, y, z) { // local chunk coords 0-15
                 return x + z * CHUNK_SIZE + y * CHUNK_SIZE * CHUNK_SIZE;
            }

            getChunk(cx, cz) {
                return this.chunks.get(this._chunkKey(cx, cz));
            }

             setChunk(cx, cz, data) {
                 const key = this._chunkKey(cx, cz);
                  // only flag if chunk is new or changed (generate calls this)
                  if(this.chunks.has(key) && this.chunks.get(key) === data) return;

                  this.chunks.set(key, data);
                  this.meshQueue.add(key);
                  // Also flag neighbours as their edge blocks might need visual update
                  this.meshQueue.add(this._chunkKey(cx + 1, cz));
                  this.meshQueue.add(this._chunkKey(cx - 1, cz));
                  this.meshQueue.add(this._chunkKey(cx, cz + 1));
                  this.meshQueue.add(this._chunkKey(cx, cz - 1));
             }

            // Get block type at global coordinates
            getBlock(x, y, z) {
                x = Math.floor(x); y = Math.floor(y); z = Math.floor(z);
                if (y < 0 || y >= WORLD_HEIGHT) return BLOCK_TYPE.AIR;
                 const cx = Math.floor(x / CHUNK_SIZE);
                 const cz = Math.floor(z / CHUNK_SIZE);
                 const chunk = this.getChunk(cx, cz);
                 if (!chunk) return BLOCK_TYPE.AIR;

                 const lx = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                 const lz = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                 try {
                   return chunk[this._blockIndex(lx, y, lz)];
                 } catch(e) {
                    console.warn("getBlock index error", x,y,z, lx,y,lz, this._blockIndex(lx,y,lz));
                     return BLOCK_TYPE.AIR;
                 }
            }

            // Set block type at global coordinates
             setBlock(x, y, z, type) {
                  x = Math.floor(x); y = Math.floor(y); z = Math.floor(z);
                  if (y < 0 || y >= WORLD_HEIGHT) return;
                   const cx = Math.floor(x / CHUNK_SIZE);
                   const cz = Math.floor(z / CHUNK_SIZE);
                   const chunk = this.getChunk(cx, cz);
                   if (!chunk) {
                      // console.warn("Set block in non-existent chunk", cx, cz);
                       return;
                   }

                   const lx = (x % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                   const lz = (z % CHUNK_SIZE + CHUNK_SIZE) % CHUNK_SIZE;
                   const index = this._blockIndex(lx, y, lz);
                   if(chunk[index] === type) return; // no change

                   chunk[index] = type;
                   const key = this._chunkKey(cx,cz);
                   this.meshQueue.add(key);

                   // Check if boundary block, flag neighbour chunk if so
                    if (lx === 0) this.meshQueue.add(this._chunkKey(cx - 1, cz));
                    if (lx === CHUNK_SIZE - 1) this.meshQueue.add(this._chunkKey(cx + 1, cz));
                    if (lz === 0) this.meshQueue.add(this._chunkKey(cx, cz - 1));
                    if (lz === CHUNK_SIZE - 1) this.meshQueue.add(this._chunkKey(cx, cz + 1));
             }

            generateChunk(cx, cz) {
                 // Don't regenerate
                 if(this.getChunk(cx,cz)) return;

                const data = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * WORLD_HEIGHT);
                 const trees = [];
                 const scale1 = 60;
                 const scale2 = 20;
                 const treeChance = noise2D(cx*0.5, cz*0.5) * 0.5 + 0.5; // varied tree density

                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const wx = cx * CHUNK_SIZE + x;
                        const wz = cz * CHUNK_SIZE + z;

                         let height = Math.floor(
                              (noise2D(wx / scale1, wz / scale1) * 0.5 + 0.5) * WORLD_HEIGHT * 0.4  // base
                             + (noise2D(wx / scale2, wz / scale2) * 0.5 + 0.5) * WORLD_HEIGHT * 0.1 // detail
                              + WORLD_HEIGHT * 0.25 // minimum height offset
                          );
                         height = Math.max(1, Math.min(WORLD_HEIGHT - 2, height));

                         const isBeach = height <= WATER_LEVEL + 1;

                        for (let y = 0; y < WORLD_HEIGHT; y++) {
                             const index = this._blockIndex(x,y,z);
                             let blockType = BLOCK_TYPE.AIR;
                             if (y < height - 3) {
                                blockType = BLOCK_TYPE.STONE;
                             } else if (y < height) {
                                 blockType = isBeach ? BLOCK_TYPE.SAND : BLOCK_TYPE.DIRT;
                             } else if (y === height) {
                                  blockType = isBeach ? BLOCK_TYPE.SAND : BLOCK_TYPE.GRASS;
                                  // Chance to spawn tree
                                  if (!isBeach && y > WATER_LEVEL + 1 && Math.random() < 0.008 * treeChance ) {
                                     trees.push({x: wx, y: y + 1, z: wz});
                                  }
                             } else if (y <= WATER_LEVEL && y > height) { // Only fill water if above terrain
                                  blockType = BLOCK_TYPE.WATER;
                             }
                             data[index] = blockType;
                        }
                    }
                }
                 this.setChunk(cx, cz, data); // set data first
                 // Add trees after base terrain is set to allow getBlock checks. Call setBlock so meshQueue is updated
                 trees.forEach(pos => this.generateTree(pos.x, pos.y, pos.z));
             }

             generateTree(x,y,z) {
                 // Abort if trying to grow too high
                  if (y > WORLD_HEIGHT - 8) return;
                 const height = Math.floor(Math.random() * 3 + 4); // 4-6 high
                  // Trunk
                  for(let i=0; i< height; i++) {
                       // Check we aren't overwriting stuff (e.g. another tree)
                      if(this.getBlock(x, y+i, z) === BLOCK_TYPE.AIR)
                           this.setBlock(x, y+i, z, BLOCK_TYPE.WOOD);
                  }
                   // Leaves - very basic canopy
                   const canopyY = y + height - 3;
                   const canopyHeight = 4;
                   for(let ly = canopyY; ly < canopyY + canopyHeight; ly++) {
                       if(ly >= WORLD_HEIGHT) continue;
                      let radius = (ly === canopyY || ly === canopyY + canopyHeight -1) ? 1 : 2;
                       if (ly >= canopyY + height -1) radius = 0; // single top block

                      for(let lx = x - radius; lx <= x + radius; lx++) {
                           for(let lz = z - radius; lz <= z + radius; lz++) {
                                // diamond shape + random
                                const dist = Math.abs(lx-x) + Math.abs(lz-z);
                                 if (dist == 0 && ly < y + height) continue; // don't overwrite trunk base

                                if ( dist <= radius*1.1+1 && Math.random() > 0.2) {
                                   // Only place if air
                                   if(this.getBlock(lx,ly,lz) === BLOCK_TYPE.AIR) {
                                        this.setBlock(lx, ly, lz, BLOCK_TYPE.LEAVES);
                                    }
                                }
                           }
                      }
                   }
             }

              // Basic face culling: only create instance if block is not surrounded by opaque blocks
              // FIX: Check if the *neighbour* is NOT OPAQUE.
              isBlockVisible(x, y, z, type) {
                     // Air is never visible
                      if(type === BLOCK_TYPE.AIR) return false;

                     // FIX #3: The line below was causing ALL water and leaf blocks to be rendered,
                     // leading to z-fighting and "glitchy" transparent rendering. Removing it
                     // allows water and leaves to be culled properly, showing only their surfaces.
                     // if(type === BLOCK_TYPE.WATER || type === BLOCK_TYPE.LEAVES) return true;

                     // Check if any neighbour is NOT opaque (i.e. Air, Water, Leaves)
                     return !OPAQUE_BLOCKS.has(this.getBlock(x + 1, y, z)) ||
                            !OPAQUE_BLOCKS.has(this.getBlock(x - 1, y, z)) ||
                            !OPAQUE_BLOCKS.has(this.getBlock(x, y + 1, z)) ||
                            !OPAQUE_BLOCKS.has(this.getBlock(x, y - 1, z)) ||
                            !OPAQUE_BLOCKS.has(this.getBlock(x, y, z + 1)) ||
                            !OPAQUE_BLOCKS.has(this.getBlock(x, y, z - 1));
              }

             updateMeshes() {
                  if(this.meshQueue.size === 0) return;
                   // Process more chunks initially
                  const maxProcess = isReady ? 4 : 15 ;
                  let count = 0;
                   const processedKeys = new Set();
                   let needsRebuild = false;
                   const tempMatrix = new THREE.Matrix4();

                  for(const key of this.meshQueue) {
                       if(count++ >= maxProcess) break;
                        // Prevent processing chunk not in memory or already processed this frame
                       if(!this.chunks.has(key) || processedKeys.has(key) ) {
                           this.meshQueue.delete(key); // clean queue
                            continue;
                       }
                       processedKeys.add(key);
                       needsRebuild = true;

                       const [cxStr, czStr] = key.split(',');
                       const cx = parseInt(cxStr);
                       const cz = parseInt(czStr);
                       const chunk = this.getChunk(cx,cz);
                        if(!chunk) continue; // Should be caught above, but safety

                       const newChunkMatrices = new Map(); // Map<type, Matrix4[]> for this chunk

                        // 1. Clear old matrix data for this chunk for all types
                        for(const blockType in BLOCK_TYPE) {
                             const typeId = BLOCK_TYPE[blockType];
                              this.chunkMatrices.delete(this._matrixKey(cx, cz, typeId));
                         }

                        // 2. Recalculate matrices for this chunk
                        for (let x = 0; x < CHUNK_SIZE; x++) {
                           for (let z = 0; z < CHUNK_SIZE; z++) {
                               for (let y = 0; y < WORLD_HEIGHT; y++) {
                                    const type = chunk[this._blockIndex(x,y,z)];
                                    if (type === BLOCK_TYPE.AIR) continue;

                                     const wx = cx * CHUNK_SIZE + x;
                                     const wz = cz * CHUNK_SIZE + z;

                                    // Simple Culling check
                                     if( !this.isBlockVisible(wx,y,wz, type) ) continue;

                                      tempMatrix.setPosition(wx + 0.5, y + 0.5, wz + 0.5);
                                       if(!newChunkMatrices.has(type)) {
                                            newChunkMatrices.set(type, []);
                                       }
                                        newChunkMatrices.get(type).push(tempMatrix.clone());
                               }
                           }
                        }
                        // 3. Store new matrices
                         newChunkMatrices.forEach((matrices, type) => {
                              this.chunkMatrices.set(this._matrixKey(cx,cz,type), matrices);
                         });
                  }

                   // remove processed keys from queue
                   processedKeys.forEach(key => this.meshQueue.delete(key));

                   if(needsRebuild) {
                      this.rebuildInstancedMeshes();
                   }
                    if (!isReady && this.meshQueue.size === 0) {
                         isReady = true;
                         statusDiv.textContent = 'World Ready. Click to Play!';
                         console.log("World fully meshed.");
                         // Do final placement after mesh is ready
                          findAndSetPlayerSpawn(true);
                    }
             }

             // Aggregate ALL matrix data across all chunks for each block type
              rebuildInstancedMeshes() {
                   const aggregatedMatrices = new Map(); // Map<type, Matrix4[]>

                   this.chunkMatrices.forEach((matrixList, key) => {
                        const parts = key.split(',');
                        if (parts.length < 3) return;
                        const type = parseInt(parts[2]);
                         if(!aggregatedMatrices.has(type)) {
                             aggregatedMatrices.set(type, []);
                         }
                         // Check if list exists and is not empty
                         if(matrixList && matrixList.length > 0) {
                           aggregatedMatrices.get(type).push(...matrixList);
                         }
                   });

                   let totalBlocks = 0;
                   aggregatedMatrices.forEach((matrices, type) => {
                       const mesh = instancedMeshes[type];
                       if(!mesh) { console.warn("No mesh for type", type); return; }
                       const count = Math.min(matrices.length, MAX_BLOCKS_PER_TYPE);
                        mesh.count = count;
                         totalBlocks += count;
                       for(let i = 0; i < count; i++) {
                           mesh.setMatrixAt(i, matrices[i]);
                       }
                        mesh.instanceMatrix.needsUpdate = true;
                   });
                    // Ensure types with 0 blocks have count 0
                   for(const type in instancedMeshes) {
                        if(!aggregatedMatrices.has(parseInt(type))) {
                             if (instancedMeshes[type].count > 0) {
                                instancedMeshes[type].count = 0;
                                instancedMeshes[type].instanceMatrix.needsUpdate = true;
                             }
                        }
                   }
                    // DEBUG LOG
                   // console.log(`Rebuilt Meshes: ${aggregatedMatrices.size} types, ${totalBlocks} total blocks visible. Queue: ${this.meshQueue.size}`);
              }
        }

      // --- PLAYER & CONTROLS ---

       // FIX: Find a solid block to stand on
       function findAndSetPlayerSpawn(force = false) {
           if(player.isLocked && !force) return; // Don't move if already playing

            let foundGround = false;
            let startY = WORLD_HEIGHT + PLAYER_HEIGHT; // Default high up
            const checkX = Math.floor(player.position.x);
            const checkZ = Math.floor(player.position.z);

            console.log(`Searching for ground at ${checkX}, ${checkZ}...`);
             for(let y = WORLD_HEIGHT -1; y > 0; y--) {
                 const blockType = world.getBlock(checkX, y, checkZ);
                 // Check against SOLID collision blocks (not air, water, leaves)
                 if (SOLID_BLOCKS_COLLISION.has(blockType) ) {
                     // Set eye level above the top surface (y+1) of the block found
                    startY = y + 1 + PLAYER_HEIGHT;
                    foundGround = true;
                    console.log(`Found ground block type ${blockType} at Y=${y}. Setting player Y to ${startY}`);
                     break;
                 }
              }
              if (!foundGround) {
                 console.warn("No solid ground found at spawn! Defaulting height.");
                  startY = WATER_LEVEL + 5; // Put above water if all else fails
                   player.position.x = startX; // reset X/Z if fell
                   player.position.z = startZ;
              }
             player.position.y = startY;
             player.velocity.y = 0;
             cameraYaw.position.copy(player.position);
        }


      function setupPointerLock() {
           pointerLockElement = document.body;
            const blocker = document.getElementById('blocker');
             const crosshair = document.getElementById('crosshair');

           blocker.addEventListener('click', () => {
               // Only allow lock if world meshing is done
                if(!player.isLocked && isReady) pointerLockElement.requestPointerLock();
           });

           document.addEventListener('pointerlockchange', () => {
               player.isLocked = document.pointerLockElement === pointerLockElement;
                blocker.style.display = player.isLocked ? 'none' : 'flex';
                 crosshair.style.display = player.isLocked ? 'block' : 'none';
                 // Reset velocity on lock/unlock
                 player.velocity.set(0,0,0);
                 player.moveForward = player.moveBackward = player.moveLeft = player.moveRight = false;
                  if(!player.isLocked && isReady) statusDiv.textContent = 'Paused. Click to Resume.';

           });
            document.addEventListener('pointerlockerror', () => {
                 console.error("Pointer Lock Error");
                  blocker.style.display = 'flex';
                   crosshair.style.display = 'none';
                  player.isLocked = false;
                  if(isReady) statusDiv.textContent = 'Pointer Lock Failed. Click to try again.';
            });

           document.addEventListener('mousemove', (event) => {
               if (!player.isLocked) return;
               cameraYaw.rotation.y -= event.movementX * MOUSE_SENSITIVITY;
               cameraPitch.rotation.x -= event.movementY * MOUSE_SENSITIVITY;
                // Clamp pitch
               cameraPitch.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch.rotation.x));
           });

            document.addEventListener('mousedown', handleMouseClick);
            document.addEventListener('wheel', handleScroll);

           const onKeyDown = (event) => {
                if (!player.isLocked) return;
               switch (event.code) {
                   case 'KeyW': case 'ArrowUp':    player.moveForward = true; break;
                   case 'KeyS': case 'ArrowDown':  player.moveBackward = true; break;
                   case 'KeyA': case 'ArrowLeft':  player.moveLeft = true; break;
                   case 'KeyD': case 'ArrowRight': player.moveRight = true; break;
                   case 'Space': if(player.onGround) {
                        player.velocity.y = JUMP_VELOCITY;
                        player.onGround = false;
                       }
                    break;
                     case 'KeyR': findAndSetPlayerSpawn(true); break; // Reset position debug
               }
                if(event.code.startsWith('Digit')) {
                   const num = parseInt(event.code.substring(5));
                   if (num >= 1 && num <= PLACEABLE_BLOCKS.length) {
                        setSelectedBlock(num - 1);
                   }
                }
           };
           const onKeyUp = (event) => {
                  switch (event.code) {
                   case 'KeyW': case 'ArrowUp':    player.moveForward = false; break;
                   case 'KeyS': case 'ArrowDown':  player.moveBackward = false; break;
                   case 'KeyA': case 'ArrowLeft':  player.moveLeft = false; break;
                   case 'KeyD': case 'ArrowRight': player.moveRight = false; break;
               }
           };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
      }

       function isSolid(x,y,z) {
             // floor happens in getBlock
            return SOLID_BLOCKS_COLLISION.has(world.getBlock(x, y, z));
       }

       // Basic AABB collision: Check blocks within player volume
       function checkCollision(pos) {
           const minX = pos.x - PLAYER_RADIUS;
           const maxX = pos.x + PLAYER_RADIUS;
            const minY = pos.y - PLAYER_HEIGHT; // From eyes down to feet
            const maxY = pos.y - 0.1 ; // Check just below eyes
            const minZ = pos.z - PLAYER_RADIUS;
            const maxZ = pos.z + PLAYER_RADIUS;

            for (let x = Math.floor(minX); x <= Math.floor(maxX); x++) {
              for (let y = Math.floor(minY); y <= Math.floor(maxY); y++) {
                 for (let z = Math.floor(minZ); z <= Math.floor(maxZ); z++) {
                     if (isSolid(x,y,z)) return true;
                 }
              }
            }
             return false;
       }

       function updatePlayer(deltaTime) {
             if(!player.isLocked || !isReady) return;

             const speed = MOVE_SPEED * deltaTime;
             const direction = new THREE.Vector3();
             const velocityXZ = new THREE.Vector3();

             // Prevent falling forever
             if(player.position.y < - 50) {
                console.log("Fell out of world, resetting.");
                 findAndSetPlayerSpawn(true);
             }


            // --- FIX #1: Player Bobbing ---
            // The old physics logic was flawed, causing the player to bob up and down.
            // This new, unified logic correctly applies gravity and handles collisions,
            // resulting in smooth movement and stable ground contact.

            // --- Y-AXIS (VERTICAL) MOVEMENT ---
            if (!player.onGround) {
                player.velocity.y += GRAVITY * deltaTime;
            }

            const nextYPos = player.position.clone();
            nextYPos.y += player.velocity.y * deltaTime;

            if (checkCollision(nextYPos)) {
                 // Hitting something vertically
                 if (player.velocity.y <= 0) { // Moving down into a floor
                     player.onGround = true;
                     player.velocity.y = 0;
                     // Snap player's feet to the top of the block they collided with
                     const feetY = Math.floor(nextYPos.y - PLAYER_HEIGHT);
                     player.position.y = feetY + 1.0 + PLAYER_HEIGHT;
                 } else { // Moving up into a ceiling
                     player.onGround = false;
                     player.velocity.y = 0; // Hit head
                     // Snap player's head to just below the ceiling
                     player.position.y = Math.floor(nextYPos.y) - 0.01;
                 }
            } else {
                 // No vertical collision, free to move
                 player.onGround = false;
                 player.position.y = nextYPos.y;
            }


            // --- FIX #2: Inverted Movement ---
            // The original movement was inverted (W moved backward). This is corrected
            // by flipping the direction of movement. Three.js cameras look down their
            // local -Z axis, so to move "forward", we must move in that direction.

            // --- XZ (HORIZONTAL) MOVEMENT & COLLISION ---
            camera.getWorldDirection(direction); // Use final camera direction
            direction.y = 0;
            direction.normalize();

            const rightDirection = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0,1,0));

            // Note: In Three.js, moving "forward" is moving along the camera's negative Z-axis.
            if (player.moveForward) velocityXZ.add(direction);
            if (player.moveBackward) velocityXZ.sub(direction);
            if (player.moveLeft) velocityXZ.sub(rightDirection);
            if (player.moveRight) velocityXZ.add(rightDirection);

            // Normalize to prevent faster diagonal movement and apply speed
            if (velocityXZ.length() > 0) {
                 velocityXZ.normalize().multiplyScalar(speed);
            }

             // Check X collision
             const nextXPos = player.position.clone();
             nextXPos.x += velocityXZ.x;
             if (!checkCollision(nextXPos)) {
                 player.position.x = nextXPos.x;
             }
              // Check Z collision
             const nextZPos = player.position.clone();
              nextZPos.z += velocityXZ.z;
               if (!checkCollision(nextZPos)) {
                 player.position.z = nextZPos.z;
              }

              cameraYaw.position.copy(player.position);
       }

       // Raycast helper: grid walking, not mesh intersection
       // returns { point: intersection point, normal: face normal, blockPos: block coords }
       function castRay() {
           const start = camera.getWorldPosition(new THREE.Vector3());
            // Ignore blocks player is inside
            if(world.getBlock(start.x, start.y, start.z) !== BLOCK_TYPE.AIR) {
              // start.add( camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(0.1) );
            }
           const direction = camera.getWorldDirection(new THREE.Vector3());
           let x = Math.floor(start.x);
           let y = Math.floor(start.y);
           let z = Math.floor(start.z);

           const stepX = Math.sign(direction.x);
           const stepY = Math.sign(direction.y);
           const stepZ = Math.sign(direction.z);
            if( stepX === 0 && stepY === 0 && stepZ === 0) return null;

           const tDeltaX = direction.x === 0 ? Infinity : Math.abs(1 / direction.x);
           const tDeltaY = direction.y === 0 ? Infinity : Math.abs(1 / direction.y);
           const tDeltaZ = direction.z === 0 ? Infinity : Math.abs(1 / direction.z);

           let tMaxX = direction.x === 0 ? Infinity : Math.abs(((stepX > 0 ? 1 : 0) + x - start.x) / direction.x);
           let tMaxY = direction.y === 0 ? Infinity : Math.abs(((stepY > 0 ? 1 : 0) + y - start.y) / direction.y);
           let tMaxZ = direction.z === 0 ? Infinity : Math.abs(((stepZ > 0 ? 1 : 0) + z - start.z) / direction.z);

             let face = new THREE.Vector3();
             const maxDistSq = MAX_RAYCAST_DIST * MAX_RAYCAST_DIST;
             let distSq = 0;
             const startInt = new THREE.Vector3(Math.floor(start.x), Math.floor(start.y), Math.floor(start.z));

             // DDA Voxel Traversal
             while(distSq < maxDistSq ) {
                  const block = world.getBlock(x,y,z);
                   // Ignore water, air, leaves for selection, BUT not if player inside it
                   const currentPos = new THREE.Vector3(x,y,z);
                    distSq = start.distanceToSquared(currentPos);
                  if( block !== BLOCK_TYPE.AIR && block !== BLOCK_TYPE.WATER && block !== BLOCK_TYPE.LEAVES && !currentPos.equals(startInt)) {
                       return {
                         blockPos: currentPos,
                          normal: face,
                          distance: Math.sqrt(distSq)
                       };
                  }

                   if (tMaxX < tMaxY) {
                       if (tMaxX < tMaxZ) {
                           x += stepX; tMaxX += tDeltaX; face.set(-stepX, 0, 0);
                       } else {
                           z += stepZ; tMaxZ += tDeltaZ; face.set(0, 0, -stepZ);
                       }
                   } else {
                       if (tMaxY < tMaxZ) {
                            y += stepY; tMaxY += tDeltaY; face.set(0, -stepY, 0);
                       } else {
                            // Need to handle Y=Z case carefully, default to Z
                           z += stepZ; tMaxZ += tDeltaZ; face.set(0, 0, -stepZ);
                       }
                   }
                   if(y < 0 || y >= WORLD_HEIGHT) break;
             }
             return null;
       }


       function updateRaycasterHighlight() {
            if(!player.isLocked || !isReady) {
                 selectionHighlightMesh.visible = false;
                 return;
            }
           const intersect = castRay();
            selectionHighlightMesh.visible = false;
           if (intersect) {
                selectionHighlightMesh.visible = true;
                 selectionHighlightMesh.position.copy(intersect.blockPos).addScalar(0.5);
           }
       }

       function handleMouseClick(event) {
             if(!player.isLocked || !isReady) return;
             event.preventDefault();
             const intersect = castRay();
              if (!intersect) return;

              if (event.button === 0) { // Left click: break
                 const { blockPos } = intersect;
                  world.setBlock(blockPos.x, blockPos.y, blockPos.z, BLOCK_TYPE.AIR);

              } else if (event.button === 2) { // Right click: place
                  const { blockPos, normal } = intersect;
                   const placePos = blockPos.clone().add(normal);

                    // Prevent placing block inside player
                   const playerMinY = player.position.y - PLAYER_HEIGHT;
                   const playerMaxY = player.position.y;
                    if ( Math.floor(placePos.x) >= Math.floor(player.position.x - PLAYER_RADIUS) &&
                         Math.floor(placePos.x) <= Math.floor(player.position.x + PLAYER_RADIUS) &&
                         Math.floor(placePos.z) >= Math.floor(player.position.z - PLAYER_RADIUS) &&
                         Math.floor(placePos.z) <= Math.floor(player.position.z + PLAYER_RADIUS) &&
                        placePos.y >= playerMinY - 0.1 && placePos.y <= playerMaxY + 0.1
                    ) {
                         //console.log("Cannot place inside player");
                         return; // trying to place inside self
                     }

                   const blockToPlace = PLACEABLE_BLOCKS[selectedBlockTypeIndex];
                   // only place into air or water
                   const targetBlock = world.getBlock(placePos.x, placePos.y, placePos.z);
                    if( targetBlock === BLOCK_TYPE.AIR || targetBlock === BLOCK_TYPE.WATER ) {
                        world.setBlock(placePos.x, placePos.y, placePos.z, blockToPlace);
                    }
              }
       }

       function handleScroll(event) {
           if(!player.isLocked || !isReady) return;
             event.preventDefault(); // Prevent page scroll
            if(event.deltaY < 0) { // Scroll up
               setSelectedBlock( (selectedBlockTypeIndex - 1 + PLACEABLE_BLOCKS.length) % PLACEABLE_BLOCKS.length );
            } else if (event.deltaY > 0) { // Scroll down
                setSelectedBlock( (selectedBlockTypeIndex + 1) % PLACEABLE_BLOCKS.length );
            }
       }

       function setSelectedBlock(index) {
           if (hotbarSlots[selectedBlockTypeIndex]) hotbarSlots[selectedBlockTypeIndex].classList.remove('selected');
            selectedBlockTypeIndex = index;
             if (hotbarSlots[selectedBlockTypeIndex]) hotbarSlots[selectedBlockTypeIndex].classList.add('selected');
       }

       function setupHotbar() {
           statusDiv.textContent = 'Setting up UI...';
           const hotbarDiv = document.getElementById('hotbar');
           hotbarDiv.innerHTML = ''; // Clear
           hotbarSlots.length = 0;

           PLACEABLE_BLOCKS.forEach((type, index) => {
               const slot = document.createElement('div');
               slot.className = 'slot';
                const miniCanvas = document.createElement('canvas');
                 // size of texture for crisp drawing
                miniCanvas.width = TEXTURE_SIZE;
                miniCanvas.height = TEXTURE_SIZE;
                const ctx = miniCanvas.getContext('2d');
                 // Must disable smoothing on context too for drawImage
                 ctx.imageSmoothingEnabled = false;

                 // Try get Top texture [2], then Side [0], then the material itself
                const mat = Array.isArray(materials[type]) ? (materials[type][2] || materials[type][0]) : materials[type];

                 if(mat && mat.map && mat.map.image) {
                   // mat.map.image IS the canvas created in createPixelTexture
                   try {
                      ctx.drawImage(mat.map.image, 0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
                   } catch (e) { console.error("Hotbar draw error", type, mat, e); }
                 } else {
                    ctx.fillStyle = 'magenta'; // error fallback
                     ctx.fillRect(0,0, TEXTURE_SIZE, TEXTURE_SIZE);
                 }
                 slot.appendChild(miniCanvas);
               hotbarDiv.appendChild(slot);
                hotbarSlots.push(slot);
           });
            setSelectedBlock(0);
             console.log("Hotbar setup");
       }

       //--- MOB ---
        function createMob() {
            const geo = new THREE.BoxGeometry(0.6, 1.8, 0.6);
            const mat = new THREE.MeshLambertMaterial({color: 0xcc4444});
             simpleMob = new THREE.Mesh(geo, mat);
             // Place near player start
             simpleMob.position.set(startX + 6, WORLD_HEIGHT, startZ + 3);
              simpleMob.velocity = new THREE.Vector3(1.0, 0, 0);
              simpleMob.startY = WORLD_HEIGHT;
              simpleMob.onGround = false;
             scene.add(simpleMob);
        }
        function updateMob(deltaTime) {
             if(!simpleMob || !isReady) return;

              // Basic Gravity
              const footBlockY = simpleMob.position.y - 1.8 - 0.1;
              simpleMob.onGround = isSolid(simpleMob.position.x, footBlockY, simpleMob.position.z);
               if(!simpleMob.onGround) {
                   simpleMob.velocity.y += GRAVITY * deltaTime;
               } else {
                   if(simpleMob.velocity.y < 0) simpleMob.velocity.y = 0;
                    simpleMob.position.y = Math.floor(simpleMob.position.y - 1.8) + 1 + 1.8; //snap
               }
              simpleMob.position.y += simpleMob.velocity.y * deltaTime;


              simpleMob.position.x += simpleMob.velocity.x * deltaTime;
              // check collision or distance
               const nextXBlock = world.getBlock(simpleMob.position.x + Math.sign(simpleMob.velocity.x)*0.4 , simpleMob.position.y - 0.9, simpleMob.position.z);
               if(Math.abs(simpleMob.position.x - (startX + 6)) > 8 || SOLID_BLOCKS_COLLISION.has(nextXBlock) ) {
                  simpleMob.velocity.x *= -1;
                  simpleMob.rotation.y = simpleMob.velocity.x > 0 ? Math.PI / 2 : -Math.PI/2;
               }

               if(simpleMob.position.y < 0) simpleMob.position.y = simpleMob.startY; // reset if fell off
        }

      // --- INIT & ANIMATE ---
      async function init() {
         try {
          statusDiv.textContent = 'Setting up Scene...';
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0x87CEEB); // Sky blue
           const fogDistNear = CHUNK_SIZE * Math.max(1, (RENDER_DISTANCE_CHUNKS-1.5));
           const fogDistFar = CHUNK_SIZE * (RENDER_DISTANCE_CHUNKS + 0.8)
           scene.fog = new THREE.Fog(0x87CEEB, fogDistNear , fogDistFar );
            console.log("Fog:", fogDistNear, fogDistFar);

           // Camera hierarchy: Yaw controls left/right, Pitch controls up/down
           camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, fogDistFar + CHUNK_SIZE);
           cameraPitch.add(camera);
           cameraYaw.add(cameraPitch);
           scene.add(cameraYaw);
           cameraYaw.position.copy(player.position);


          renderer = new THREE.WebGLRenderer({ antialias: false }); // No antialias for pixel look
          renderer.setSize(window.innerWidth, window.innerHeight);
           renderer.shadowMap.enabled = false; // Shadows are expensive
           renderer.setPixelRatio(window.devicePixelRatio);
          document.body.appendChild(renderer.domElement);

           // Lighting
           const ambientLight = new THREE.AmbientLight(0x888899);
           scene.add(ambientLight);
           const directionalLight = new THREE.DirectionalLight(0xffffee, 1.0);
           directionalLight.position.set(0.4, 1, 0.6).normalize();
           scene.add(directionalLight);

           raycaster = new THREE.Raycaster();
           // Initialize noise with a seed for consistency, or Math.random for different each time
            noise2D = createNoise2D(Math.random);
           world = new World();

           createMaterials();
           setupHotbar(); // Do early so images are ready

           // Create Instanced Meshes for each type
            for (const key in BLOCK_TYPE) {
                 const type = BLOCK_TYPE[key];
                 if (type === BLOCK_TYPE.AIR) continue;
                 const material = materials[type];
                  if(!material) { console.warn("No material for type", type); continue;}
                  //console.log("Creating mesh for ", key, "max:", MAX_BLOCKS_PER_TYPE);
                 const mesh = new THREE.InstancedMesh(blockGeometry, material, MAX_BLOCKS_PER_TYPE);
                  mesh.count = 0; // Start with 0 blocks
                  mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage ); // matrix will change often
                 instancedMeshes[type] = mesh;
                 scene.add(mesh);
            }

           console.log("Generating world data...");
            statusDiv.textContent = 'Generating Terrain...';
            const worldDiameter = RENDER_DISTANCE_CHUNKS * 2 + 1;
            // Generate chunks around 0,0 first, then translate player
            for (let cx = 0; cx < worldDiameter; cx++) {
                 for (let cz = 0; cz < worldDiameter; cz++) {
                    world.generateChunk(cx, cz);
                }
            }
             console.log(`Generated ${world.chunks.size} chunks. Meshing queue size: ${world.meshQueue.size}`);
             statusDiv.textContent = `Building World Meshes (${world.meshQueue.size})...`;

            // Try to place player, but mesh isn't ready yet. Will call again when queue empty.
             findAndSetPlayerSpawn();

             // Selection highlight box
             const highlightGeo = new THREE.EdgesGeometry( new THREE.BoxGeometry(1.02, 1.02, 1.02));
             const highlightMat = new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 2 });
              selectionHighlightMesh = new THREE.LineSegments(highlightGeo, highlightMat);
               selectionHighlightMesh.visible = false;
              scene.add(selectionHighlightMesh);

           setupPointerLock();
            createMob();

           window.addEventListener('resize', onWindowResize);
           console.log("Init Complete. Starting animation loop.");
            requestAnimationFrame(animate); // Start loop here
         } catch (e) {
             console.error("FATAL INIT ERROR:", e);
              statusDiv.innerHTML = `INIT ERROR:<br> ${e.message} <br> Check console (F12)`;
         }
      }

       function onWindowResize() {
             camera.aspect = window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
       }

      function animate(time) {
          requestAnimationFrame(animate);

           const deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            const effectiveDeltaTime = Math.min(deltaTime, 0.05); // limit physics step

            if(!isReady && world) {
                 statusDiv.textContent = `Building World Meshes (${world.meshQueue.size})...`;
            }

           updatePlayer(effectiveDeltaTime);
           updateMob(effectiveDeltaTime);
           if(world) world.updateMeshes(); // process mesh queue
           updateRaycasterHighlight();

           if ( time - debugTime > 1000) { // Update pos display once per sec
              posDebug.textContent = `Pos: ${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;
               debugTime = time;
           }

          renderer.render(scene, camera);
      }

      // Start init after modules should be ready
      // window.onload can sometimes be too early for modules
      setTimeout(init, 100);

    </script>

</body>
</html>